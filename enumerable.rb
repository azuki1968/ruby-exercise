#!usr/bin/ruby

#Enumerableモジュール
#ArrayクラスやHashクラスにインクルードされているモジュール
#多くの有用なメソッドをクラスに追加する。
#全てのメソッドがeachメソッドを元に定義されているため、eachメソッドが
#定義されているクラス(Array,Dir,File,Hash等)であれば、これらの多くの
#メソッドをそのクラスで#利用できる。
#
#基本となる書き方
# [配列].メソッド名 {処理}
#
#各メソッドの処理
# map,collet       各要素に対してブロックを実行した結果を配列にして返却
[1,2,3,4,5].map {|i| i **2 }   #=> [1, 4, 9, 16, 25]
#
# each_with_index  要素とそのインデックスをブロックに渡して実行
[:a,:b,:c,:d,:e].each_with_index { |idx, i| puts "#{idx} => #{i}"} 
#a => 0
#b => 1
#c => 2
#d => 3
#e => 4
#
# inject,reduce    要素に対して畳み込み演算を実行した結果を返却
[1,2,3,4,5].inject(0) { | sum, i| sum + i }  #=> 15
#  説明 sumの初期値はinject(0)で指定されているが、省略値は0なので記述しなくてもよい
#  参考 Arrayのsumメソッドで書いても同じ結果  [1,2,3,4,5].sum
#
# each_cons   要素を指定された数で区切ってブロックに渡す
[1,2,3,4,5].each_cons(3) { |i| p i }
#[1, 2, 3]
#[2, 3, 4]
#[3, 4, 5]
#
# each_slice  要素を指定された数ずつ渡す
[1,2,3,4,5].each_slice(3) { |i| p i }
#[1, 2, 3]
#[4, 5]
#
# reverse_each
[1,2,3,4,5].reverse_each { |i| p i }
#5
#4
#3
#2
#1
#
# all?   全ての要素が真ならtrueを返却
[1,nil,5].all?   #=> false
# any?   真である要素がひとつでもあればtrueを返却
[1,nil,5].any?   #=> true
# none?  全ての要素が偽であればtrueを返却
[nil,nil,nil].none?   #=> true
# one?   ひとつの要素だけが真であればtrueを返却
[1,nil,3].one?   #=> false
[nil,nil,3].one?   #=> true
#
# member?, include?  指定された値と==メソッドがtrueとなる要素があればtrueを返却
[1,2,3,4,5].include?(3)   #=> true
#
# find, detect  ブロックを評価して最初に真となる要素を返却
[1,2,3,4,5].find { |i| i % 2 == 0}     #=> 2
#
# find_index  ブロックを評価して最初に真となる要素のインデックスを返却
[1,2,3,4,5].find_index { |i| i % 2 == 0}     #=> 1
#
# find_all, select  ブロックを評価して真となる要素を全て返却
[1,2,3,4,5].find { |i| i % 2 == 0}     #=> [2, 4]
#
# sort   要素を<=>メソッドで比較して昇順にソートした配列を新たに生成して返却
["aaa","b","cc"].sort{ |a,b| a.length <=> b.length}   #=> ["b", "cc", "aaa"]
#
# sort_by  ブロックの評価結果を<=>メソッドで比較して昇順にソートした配列を使って、
#元の配列をソートした新しい配列を生成して返却
["aaa","b","cc"].sort_by{ |a| a}          #=> ["aaa", "b", "ccc"]
["aaa","b","cc"].sort_by{ |a| a.length}   #=> ["b", "cc", "aaa"]
#
# max, min  要素の最大値と最小値を返却（ <=>メソッドで比較）
[1,2,3,4,5].max    #=> 5
[1,2,3,4,5].min    #=> 1
#
# max_by, min_by   ブロックの評価結果が最大の要素と最小の要素を返却
[1,2,3,4,5].max_by { |i| i % 2 + i }    #=> 5
[1,2,3,4,5].min_by { |i| i % 2 + i }    #=> 1
#
# count    要素数を返却
[1,2,3,4,5].count    #=> 5
#
# cycle   要素を先頭から順に取り出し、末尾まで到達したら再度先頭に戻り、繰り返す
#["a","b","c"].cycle { |a| p a} 
#
# group_by   ブロックの評価結果をキーとして、同じキーを持つ要素を配列とした
#            ハッシュを返却（例では除算の余りがキー）
(1..10).group_by { |i| i % 2 }  #=> {1=>[1, 3, 5, 7, 9], 0=>[2, 4, 6, 8, 10]}
#
# zip   自身と引数に指定した配列から、１つずつ要素を取り出して配列を作り、
#       それを要素とする配列を返却
[:a,:b,:c].zip([1, 2, 3], ["a", "b", "c"])  #=> [[:a, 1, "a"], [:b, 2, "b"], [:c, 3, "c"]]
#
# take    先頭から指定した数の要素を配列として返却
# first   firstメソッドのみ数を指定しない場合に先頭の要素のみ返却
[:a,:b,:c].take(2)    #=> [:a, :b]
[:a,:b,:c].first(2)   #=> [:a, :b]
[:a,:b,:c].first      #=> a
#
# take_while    先頭からブロックを評価し、最初に偽となった要素の直前までを返却
[:a,:b,:c, :d, :e].take_while { |e| e != :d}    #=> [:a, :b, :c]
#
# drop   takeメソッドとは逆に先頭から指定した数の要素を取り除いた残りの要素を
#        配列として返却
[:a,:b,:c,:d,:e].drop(3)    #=> [:d, :e]
#
# drop _while   先頭からブロックを評価し、最初に偽となった要素の手前までを
#               切り捨て、残りの要素を配列として返却
[:a,:b,:c, :d, :e].drop_while { |e| e != :c}    #=> [:c, :d, :e]
#
# select   各要素に対してブロックの評価結果が真であった要素を含む配列を返却
# reject   各要素に対してブロックの評価結果が偽であった要素を含む配列を返却
[1,2,3,4,5].select { |i| i % 2 == 0 }   #=> [2, 4]
[1,2,3,4,5].reject { |i| i % 2 == 0 }   #=> [1, 3, 5]
#
# lazy  mapメソッドやselectメソッドなどのメソッドが遅延評価を行うよう再定義される
a = [1,2,3,4,5].select { |i| i % 2 == 0 }  #<Enumerator::Lazy:0x000055c38c5a67e8>
b = a.map { |i|  i * 2 }  #<Enumerator::Lazy:0x000055c38c5a5a00>
c = a.take(3)             #<Enumerator::Lazy:0x000055c38c4a6a50>
c .to_a  # ここで評価される　[2, 4]